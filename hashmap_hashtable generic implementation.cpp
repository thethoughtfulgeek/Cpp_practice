/*

This is a generic hash-map/hash-table implementation for C++
You can use this as a basic infrastructure for some program
requiring hash maps/hash tables. 

It does not rely upon the STL containers like 
unordered_map or map or list

This is the raw implementation as per my understanding

Author: Jaineel Dalal <jdalal@andrew.cmu.edu>
Date: 09/07/2015

*/

#include <iostream>
#include <vector>


// Used for avoiding collisions in a Hashtable
class Node
{
private:
	int value_;
	Node* next_;

public:
	Node()
	{
		// default constructor
	}

	Node( int data, Node* node = NULL )
	{
		value_ = data;
		next_ = node;
	}

	~Node()
	{
		// Destructor
	}

	// Returns the value of the given Node.
	int getValue()
	{
		return value_;
	}

	// Gets the next node
	Node* getNext()
	{
		return next_;
	}

	// Sets the next node
	void setNext( Node* node )
	{
		next_ = node;
	}

};

// The actual HashTable implementation
class HashTable
{
private:
	// KEY = Vector Index
	// Value at that vector index will be the head address of a linked list node
	// Accessing that value will lead us to the actual chain of the linked list corresponding to that key

	// Initial size of the vector where keys are mapped
	int vector_size_;

	// Indexes of this array will be the keys generated by the hashing function
	// It shall hold the head address of each linked list which will point to the next node and so on
	// It is kept as a vector since we require a dynamic array here due to frequent resizing
	std::vector<Node*> hash_array_;

protected:
	// Hashing function (generic implementation here) Actual will depend upon the application
	// Takes in a given input value which can be a string, int, char, anything
	// gives out a (int) vector index (i.e. a key!) as per the given size of the vector
	int hashing_function( int given_num );

public:
	HashTable()
	{
		// Default constructor
	}

	HashTable( int array_length )
	{
		vector_size_ = array_length;
		for (int i = 0; i < vector_size_; ++i)
		{
			hash_array_[i] = NULL;
		}
	}

	~HashTable()
	{
		// Yet to define destructor
	}

	// Inserting some value into the hashtable
	// Key generation is handled internally only
	void insert( int randomnum );

	// Search for a particular number inside the Hashtable
	// Return NULL if absent, returns the Node pointer if present
	// Key generation done internally
	Node* get( int randomnum );

	// Deleting a value from the hashtable
	// Searches first in the given Hashtable for the number
	// If not found, returns an error else deletes the Node and exits after appropriate node adjustments
	void deletenum( int randomnum );
};

int HashTable::hashing_function( int given_num )
{	
	int map_code, key;
	
	// Do some problem specific hashing to generate a random int number from a given string/char/int and put it into map_code

	// Compress this map_code to the given vector range by using the modulo operator with vector_size

	key = map_code % vector_size_;

}

void HashTable::insert( int randomnum )
{
	int key;

	key = hashing_function( randomnum );

	// If the given bucket is empty right now
	if ( hash_array_[key] == NULL )
	{
		hash_array_[key] = new Node( randomnum );
	}

	else
	{
		// There has been a collision! 
		// Go to the corresponding bucket and add the new element at the front, thus forming a chain in this way.
		// Basically the front element would keep on changing each time
		Node* temp_node = hash_array_[key];

		hash_array_[key] = new Node( randomnum, temp_node );
	}
}

Node* HashTable::get( int randomnum )
{
	int key;

	key = hashing_function( randomnum );

	Node* current_node = hash_array_[key];

	while( current_node->getValue() != randomnum )
	{
		current_node = current_node->getNext();
		if ( current_node == NULL )
		{
			std::cout<<"Value not found!"<<'\n';
			return NULL;
		}
	}
	return current_node;
}

void HashTable::deletenum( int randomnum )
{
	int key;

	key = hashing_function( randomnum );

	Node* current_node = hash_array_[key];
	Node* prev_node;


	if ( current_node->getValue() == randomnum )
	{
		delete current_node;
		hash_array_[key] = NULL;
	}
	else
	{
		while( current_node->getValue() != randomnum )
		{
			prev_node = current_node;
			current_node = current_node->getNext();
			if ( current_node == NULL )
			{
				std::cout<<"Error! Value not found"<<'\n';
			}
		}
		prev_node->setNext( current_node->getNext() );
		delete current_node;
	}
}

int main()
{
}